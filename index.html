<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8" />
    <title>สรุป Interfaces / Generics / Wildcards / Nested Classes</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
         :root {
            --bg-main: #050816;
            --bg-card: #0b1020;
            --bg-card-soft: #11162b;
            --accent: #7f5af0;
            --accent-soft: rgba(127, 90, 240, 0.25);
            --accent-2: #2cb67d;
            --text-main: #e5e7f0;
            --text-muted: #9ca3c7;
            --border-subtle: rgba(148, 163, 184, 0.25);
            --code-bg: #050816;
            --tag-bg: rgba(148, 163, 184, 0.18);
            --danger: #f97373;
            --success: #4ade80;
            --warning: #facc15;
            --radius-lg: 18px;
            --radius-md: 12px;
            --shadow-soft: 0 18px 40px rgba(15, 23, 42, 0.75);
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: radial-gradient(circle at top, #1f233a 0, #050816 40%, #020617 100%);
            color: var(--text-main);
            line-height: 1.7;
            padding: 0;
            margin: 0;
        }
        
        .page {
            max-width: 1100px;
            margin: 0 auto;
            padding: 1.2rem 1rem 3rem;
        }
        
        @media (min-width: 768px) {
            .page {
                padding: 1.5rem 1.5rem 4rem;
            }
        }
        /* Header / Hero */
        
        .hero {
            position: sticky;
            top: 0;
            z-index: 20;
            backdrop-filter: blur(18px);
            background: linear-gradient(to bottom, rgba(5, 8, 22, 0.94), rgba(5, 8, 22, 0.7));
            border-bottom: 1px solid rgba(148, 163, 184, 0.15);
            margin: -1.2rem -1rem 1.2rem;
            padding: 0.9rem 1rem 0.8rem;
        }
        
        @media (min-width: 768px) {
            .hero {
                margin: -1.5rem -1.5rem 1.5rem;
                padding: 1rem 1.5rem;
            }
        }
        
        .hero-inner {
            max-width: 1100px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
        }
        
        .hero-title-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
        }
        
        .hero-title {
            font-size: 1.1rem;
            font-weight: 600;
            letter-spacing: 0.03em;
            text-transform: uppercase;
            color: #e5e7ff;
        }
        
        @media (min-width: 768px) {
            .hero-title {
                font-size: 1.25rem;
            }
        }
        
        .hero-badge {
            font-size: 0.7rem;
            padding: 0.18rem 0.55rem;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid rgba(148, 163, 184, 0.3);
            color: var(--text-muted);
            white-space: nowrap;
        }
        
        .hero-sub {
            font-size: 0.8rem;
            color: var(--text-muted);
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
            align-items: center;
        }
        
        .hero-tags {
            display: inline-flex;
            flex-wrap: wrap;
            gap: 0.3rem;
        }
        
        .hero-tag {
            font-size: 0.7rem;
            padding: 0.08rem 0.5rem;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid rgba(78, 87, 131, 0.6);
            color: var(--text-muted);
        }
        /* Nav pills */
        
        .nav {
            margin-top: 0.5rem;
            display: flex;
            gap: 0.5rem;
            overflow-x: auto;
            padding-bottom: 0.1rem;
            scrollbar-width: none;
        }
        
        .nav::-webkit-scrollbar {
            display: none;
        }
        
        .nav-link {
            font-size: 0.8rem;
            padding: 0.3rem 0.75rem;
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 184, 0.3);
            background: rgba(15, 23, 42, 0.8);
            color: var(--text-main);
            text-decoration: none;
            white-space: nowrap;
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            transition: background 0.2s, border-color 0.2s, transform 0.1s;
        }
        
        .nav-link span {
            font-size: 0.7rem;
            opacity: 0.8;
        }
        
        .nav-link:hover {
            background: radial-gradient(circle at top left, rgba(127, 90, 240, 0.3), rgba(15, 23, 42, 0.95));
            border-color: var(--accent);
            transform: translateY(-1px);
        }
        /* Sections / cards */
        
        .section {
            margin-bottom: 1.5rem;
            border-radius: var(--radius-lg);
            background: radial-gradient(circle at top left, rgba(127, 90, 240, 0.13), rgba(15, 23, 42, 0.98));
            border: 1px solid rgba(148, 163, 184, 0.25);
            box-shadow: var(--shadow-soft);
            overflow: hidden;
        }
        
        .section-header {
            padding: 0.85rem 1rem;
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.6rem;
            background: linear-gradient(90deg, rgba(15, 23, 42, 0.96), rgba(39, 39, 89, 0.9));
        }
        
        @media (min-width: 768px) {
            .section-header {
                padding: 1rem 1.2rem;
            }
        }
        
        .section-title {
            font-size: 1rem;
            font-weight: 600;
            color: #e5e7ff;
        }
        
        .section-subtitle {
            font-size: 0.78rem;
            color: var(--text-muted);
        }
        
        .section-body {
            padding: 0.85rem 1rem 1rem;
        }
        
        @media (min-width: 768px) {
            .section-body {
                padding: 1rem 1.2rem 1.3rem;
            }
        }
        
        h3.topic {
            font-size: 0.98rem;
            margin-top: 0.35rem;
            margin-bottom: 0.4rem;
            color: var(--accent-2);
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        
        h3.topic span.badge {
            font-size: 0.7rem;
            padding: 0.05rem 0.5rem;
            border-radius: 999px;
            border: 1px solid rgba(56, 189, 248, 0.5);
            color: #bae6fd;
            background: rgba(8, 47, 73, 0.6);
        }
        
        p {
            font-size: 0.86rem;
            color: var(--text-main);
            margin-bottom: 0.5rem;
        }
        
        ul {
            list-style: none;
            padding-left: 0;
            margin-bottom: 0.5rem;
        }
        
        ul li {
            position: relative;
            padding-left: 1.05rem;
            font-size: 0.86rem;
            color: var(--text-main);
            margin-bottom: 0.25rem;
        }
        
        ul li::before {
            content: "•";
            position: absolute;
            left: 0;
            top: 0.03rem;
            color: var(--accent);
            font-size: 0.8rem;
        }
        
        .hint {
            font-size: 0.8rem;
            color: var(--text-muted);
            padding: 0.4rem 0.7rem;
            border-radius: var(--radius-md);
            background: rgba(15, 23, 42, 0.9);
            border: 1px dashed rgba(148, 163, 184, 0.4);
            margin: 0.3rem 0 0.6rem;
        }
        
        .keyword {
            display: inline-block;
            padding: 0.1rem 0.45rem;
            border-radius: 999px;
            background: var(--tag-bg);
            font-size: 0.74rem;
            color: #e5e7ff;
            margin-right: 0.1rem;
        }
        /* Code blocks */
        
        pre {
            margin: 0.4rem 0 0.6rem;
            padding: 0.65rem 0.75rem;
            background: radial-gradient(circle at top left, #020617, #020317);
            border-radius: var(--radius-md);
            border: 1px solid rgba(148, 163, 184, 0.35);
            overflow-x: auto;
            font-size: 0.78rem;
            line-height: 1.6;
            scrollbar-width: thin;
        }
        
        code {
            font-family: "JetBrains Mono", "Fira Code", Consolas, monospace;
            color: #e5e7ff;
        }
        /* Tables */
        
        .table-wrapper {
            margin: 0.5rem 0 0.8rem;
            border-radius: var(--radius-md);
            border: 1px solid rgba(148, 163, 184, 0.35);
            overflow: hidden;
            background: rgba(15, 23, 42, 0.9);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }
        
        thead {
            background: linear-gradient(90deg, rgba(15, 23, 42, 0.97), rgba(55, 48, 163, 0.95));
        }
        
        th,
        td {
            padding: 0.45rem 0.6rem;
            text-align: left;
            border-bottom: 1px solid rgba(51, 65, 85, 0.6);
        }
        
        th {
            font-weight: 600;
            color: #e5e7ff;
            white-space: nowrap;
        }
        
        td {
            color: var(--text-main);
        }
        
        tbody tr:nth-child(even) {
            background: rgba(15, 23, 42, 0.85);
        }
        
        tbody tr:nth-child(odd) {
            background: rgba(15, 23, 42, 0.6);
        }
        /* Glossary tags */
        
        .glossary-group {
            display: grid;
            grid-template-columns: minmax(0, 1fr);
            gap: 0.4rem;
            margin-bottom: 0.8rem;
        }
        
        @media (min-width: 640px) {
            .glossary-group {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }
        
        .glossary-item {
            background: rgba(15, 23, 42, 0.9);
            border-radius: var(--radius-md);
            border: 1px solid rgba(148, 163, 184, 0.35);
            padding: 0.5rem 0.6rem;
        }
        
        .glossary-term {
            font-size: 0.82rem;
            font-weight: 600;
            color: #e5e7ff;
            margin-bottom: 0.15rem;
        }
        
        .glossary-desc {
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        .pill-row {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            margin: 0.25rem 0 0.4rem;
        }
        
        .pill {
            font-size: 0.7rem;
            padding: 0.08rem 0.5rem;
            border-radius: 999px;
            background: rgba(30, 64, 175, 0.5);
            color: #dbeafe;
            border: 1px solid rgba(96, 165, 250, 0.7);
        }
        /* Small labels */
        
        .label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
        }
        
        .divider {
            margin: 0.5rem 0 0.7rem;
            border-top: 1px dashed rgba(148, 163, 184, 0.3);
        }
    </style>
</head>

<body>
    <header class="hero">
        <div class="hero-inner">
            <div class="hero-title-row">
                <div>
                    <div class="hero-title">Java OOP Cheatsheet – Interfaces, Generics, Wildcards, Nested Classes</div>
                </div>
                <div class="hero-badge">CSC250 Notes</div>
            </div>
            <div class="hero-sub">
                สรุปแน่น ๆ อ่านง่าย ใช้ติวก่อนสอบได้เลย
                <span class="hero-tags">
          <span class="hero-tag">Interfaces</span>
                <span class="hero-tag">Generics &amp; PECS</span>
                <span class="hero-tag">Nested / Anonymous</span>
                </span>
            </div>
            <nav class="nav">
                <a href="#sec6" class="nav-link">บทที่ 6 <span>Interfaces</span></a>
                <a href="#sec7" class="nav-link">บทที่ 7 <span>Generics &amp; Casting</span></a>
                <a href="#sec8" class="nav-link">บทที่ 8 <span>Wildcards &amp; PECS</span></a>
                <a href="#sec9" class="nav-link">บทที่ 9 <span>Nested / Inner</span></a>
                <a href="#glossary" class="nav-link">Glossary <span>ศัพท์สำคัญ</span></a>
            </nav>
        </div>
    </header>

    <main class="page">

        <!-- SECTION 6 -->
        <section id="sec6" class="section">
            <div class="section-header">
                <div>
                    <div class="section-title">บทที่ 6 – Interfaces</div>
                    <div class="section-subtitle">Module6_Interfaces_CSC250</div>
                </div>
            </div>
            <div class="section-body">

                <h3 class="topic">6.1 Interface คืออะไร <span class="badge">สัญญา/Spec</span></h3>
                <p><strong>Interface</strong> = “<strong>สัญญา / Spec</strong> ว่าคลาสที่มานำไปใช้ต้องมีเมธอดอะไรบ้าง”</p>
                <ul>
                    <li>เมธอดใน interface เป็น <code>public</code> + <code>abstract</code> โดยปริยาย (ไม่ต้องเขียนก็ถือว่า abstract)</li>
                    <li>ตัวแปร (field) ใน interface เป็น <code>public static final</code> (constant) โดยอัตโนมัติ</li>
                    <li>ไม่มี constructor → สร้าง object จาก interface โดยตรงไม่ได้</li>
                    <li>คลาสหนึ่ง ๆ <code>implements</code> ได้หลาย interface (multiple inheritance of type)</li>
                    <li>Java 8/9 ขึ้นไป:
                        <ul>
                            <li>มี <code>default</code> method (มี body ใน interface ได้)</li>
                            <li>มี <code>static</code> method ใน interface</li>
                            <li>มี <code>private</code> method ได้ (ใช้เป็น helper ภายใน interface เอง)</li>
                        </ul>
                    </li>
                </ul>
                <div class="hint">
                    <span class="keyword">implements</span> = ให้คลาส “รับปากว่าจะทำตามสัญญา” ของ interface นั้น ๆ
                </div>

                <h3 class="topic">6.2 ตัวอย่างพื้นฐาน – <code>Animal</code>, <code>Dog</code>, <code>Cat</code></h3>
                <pre><code>interface Animal {
    void makeSound(); // abstract method
    void eat();       // abstract method
}

class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Woof! Woof!");
    }
    @Override
    public void eat() {
        System.out.println("Dog is eating bones.");
    }
}</code></pre>
                <ul>
                    <li><code>Animal</code> เป็น interface กำหนดสัญญาว่า “ใครเป็น Animal ต้องมี <code>makeSound()</code> และ <code>eat()</code>”</li>
                    <li><code>Dog implements Animal</code> → Dog ต้องเขียนเมธอดทั้ง 2 ตัวให้ครบ</li>
                    <li>ใน <code>main</code> เราสามารถถือ reference เป็น <code>Animal</code> แต่ผูกกับ object จริงเป็น <code>new Dog()</code> หรือ <code>new Cat()</code> ได้
                        <div class="hint">แนวคิด: <strong>เขียนโค้ดกับ interface ไม่ใช่ implementation</strong> → เปลี่ยน/ขยายในอนาคตง่าย</div>
                    </li>
                </ul>

                <h3 class="topic">6.3 Interface vs Abstract Class</h3>

                <div class="table-wrapper">
                    <table>
                        <thead>
                            <tr>
                                <th>เรื่อง</th>
                                <th>Interface</th>
                                <th>Abstract Class</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>keyword</td>
                                <td><code>interface</code></td>
                                <td><code>abstract class</code></td>
                            </tr>
                            <tr>
                                <td>เมธอด</td>
                                <td><code>abstract</code> + <code>default</code> + <code>static</code></td>
                                <td><code>abstract</code> + concrete (มี body ปกติ)</td>
                            </tr>
                            <tr>
                                <td>ตัวแปร</td>
                                <td><code>public static final</code> เท่านั้น</td>
                                <td>field ปกติได้ทุกแบบ</td>
                            </tr>
                            <tr>
                                <td>constructor</td>
                                <td>❌ ไม่มี</td>
                                <td>✅ มีได้</td>
                            </tr>
                            <tr>
                                <td>สืบทอด</td>
                                <td>class <code>implements</code> ได้หลาย interface</td>
                                <td>class <code>extends</code> ได้แค่ abstract class เดียว</td>
                            </tr>
                            <tr>
                                <td>ใช้เมื่อ</td>
                                <td>นิยาม “ความสามารถ / บทบาท”</td>
                                <td>นิยาม “ชนิดพื้นฐานที่มี state + พฤติกรรมร่วมกัน”</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="hint">
                    ถ้าอยากได้ “<strong>สัญญา/ความสามารถ</strong>” → ใช้ <strong>interface</strong> (เช่น <code>Comparable</code>, <code>Iterable</code>)<br/> ถ้าต้องการ “<strong>แม่แบบ</strong> ที่มี field + code ร่วมกัน แล้ว subclass สานต่อ” → ใช้ <strong>abstract class</strong>
                </div>

                <h3 class="topic">6.4 Multiple Inheritance &amp; ปัญหา Diamond</h3>
                <p>ใน C++ คลาสสามารถสืบทอดได้หลายตัวพร้อมกัน → ถ้าทุกตัวมีเมธอดชื่อเดียวกันจะเกิดปัญหา <strong>diamond problem</strong> เช่นเรียก <code>D.show()</code> ไม่รู้ใช้ของ B หรือ C</p>
                <ul>
                    <li>Java แก้โดย:
                        <ul>
                            <li>ไม่ให้ <code>extends</code> หลายคลาส</li>
                            <li>แต่ให้ <code>implements</code> หลาย interface ได้</li>
                        </ul>
                    </li>
                    <li>ถ้า interface สองตัวมี <code>default</code> method ชื่อเหมือนกัน แล้วคลาส <code>implements</code> ทั้งคู่ → ต้อง override เองเพื่อแก้ conflict</li>
                </ul>

                <pre><code>public interface LogA { 
    default void audit(double amount){
        System.out.println("LogA: " + amount);
    } 
}
public interface LogB { 
    default void audit(double amount){
        System.out.println("LogB: " + amount);
    }
}

public class CombinedLogger implements LogA, LogB {
    @Override 
    public void audit(double amount) {
        LogA.super.audit(amount);
        LogB.super.audit(amount);
    }
}</code></pre>

                <p><code>CombinedLogger</code> ต้อง override <code>audit()</code> แล้วเลือกเองว่าจะเรียกของ <code>LogA</code>, <code>LogB</code> หรือผสมสองอัน</p>

                <h3 class="topic">6.5 Interfaces + Strategy Pattern (Payment / Discount)</h3>

                <p><strong>PaymentProcessor</strong></p>
                <pre><code>public interface PaymentProcessor {
    boolean charge(double amount);

    default void audit(double amount, boolean ok) { ... }

    static boolean valid(double amount) { return amount >= 0.0; }

    private String fmt(double v) { ... } // Java 9+
}</code></pre>
                <ul>
                    <li><code>charge</code> → สัญญาว่าต้อง implement วิธี “เรียกเก็บเงิน”</li>
                    <li><code>audit</code> → default method มีโค้ดกลางใช้ log ผล</li>
                    <li><code>static valid</code> → helper เช็คว่าเงินไม่ติดลบ</li>
                    <li><code>private fmt</code> → method ใช้ภายใน interface เอง</li>
                </ul>
                <p><strong>SandboxProcessor / FailoverProcessor</strong> → เป็น strategy ต่าง ๆ ที่ <code>implements PaymentProcessor</code> เพื่อ “เปลี่ยนวิธีคิดเงิน” ได้ง่าย</p>

                <p><strong>Discount (functional interface)</strong></p>
                <pre><code>@FunctionalInterface
public interface Discount {
    double apply(double total);
    static Discount none()         { return t -&gt; t; }
    static Discount percent(double rate) { return t -&gt; t * (1.0 - rate); }
}</code></pre>
                <ul>
                    <li>เป็น <strong>functional interface</strong> = มี abstract method เดียว (<code>apply</code>) → ใช้กับ lambda ได้</li>
                    <li>มี static method คืน lambda สำเร็จรูป (<code>none()</code>, <code>percent(rate)</code>)</li>
                </ul>

                <p><strong>Checkout</strong> จะ “ถือ” ทั้ง <code>PaymentProcessor</code> และ <code>Discount</code> เป็น dependency → เปลี่ยนกลยุทธ์ได้ runtime</p>
                <pre><code>public boolean process(double total) {
    double toCharge = (discount == null) ? total : discount.apply(total);
    return processor.charge(toCharge);
}</code></pre>

                <div class="hint">
                    ข้อดี: แยก “<strong>กลยุทธ์จ่ายเงิน</strong>” กับ “<strong>กลยุทธ์ลดราคา</strong>” เป็น interface ทำให้เปลี่ยนสลับแบบ plug-in ได้ง่ายมาก
                </div>
            </div>
        </section>

        <!-- SECTION 7 -->
        <section id="sec7" class="section">
            <div class="section-header">
                <div>
                    <div class="section-title">บทที่ 7 – Generics &amp; Casting</div>
                    <div class="section-subtitle">Module7_Generics_CSC250</div>
                </div>
            </div>
            <div class="section-body">

                <h3 class="topic">7.1 Casting</h3>
                <p><span class="label">Primitive Casting</span></p>
                <ul>
                    <li><strong>Widening (ขยาย)</strong> – แปลงจาก type เล็ก → ใหญ่ เช่น <code>int → long → float → double</code>
                        <ul>
                            <li>ทำอัตโนมัติ เพราะข้อมูลไม่หาย</li>
                        </ul>
                    </li>
                    <li><strong>Narrowing (หด)</strong> – ใหญ่ → เล็ก เช่น <code>double → int</code>
                        <ul>
                            <li>ต้องเขียน cast เอง <code>(int) x</code></li>
                            <li>อาจข้อมูลหาย (ทศนิยมหาย, overflow)</li>
                        </ul>
                    </li>
                </ul>

                <p><span class="label">Reference Casting (object)</span></p>
                <ul>
                    <li><strong>Upcasting</strong> – subclass → superclass เช่น <code>Dog</code> เป็น <code>Animal</code>
                        <ul>
                            <li>ทำอัตโนมัติ ปลอดภัย</li>
                        </ul>
                    </li>
                    <li><strong>Downcasting</strong> – superclass → subclass เช่น <code>Animal → Dog</code>
                        <ul>
                            <li>ต้อง cast เอง <code>(Dog) a</code></li>
                            <li>ควรเช็คด้วย <code>instanceof</code> เพราะถ้าไม่ใช่ชนิดนั้นจริง → <code>ClassCastException</code></li>
                        </ul>
                    </li>
                </ul>

                <div class="divider"></div>

                <h3 class="topic">7.2 Generics คืออะไร ทำไมต้องใช้</h3>
                <p>ถ้าใช้ <code>Object</code> ธรรมดา เวลาเอาค่ากลับต้อง cast เอง → เสี่ยง error runtime</p>
                <p><strong>Generics ช่วยให้</strong></p>
                <ul>
                    <li><strong>Type-Safe</strong> – เช็คชนิดตั้งแต่ compile time</li>
                    <li><strong>ลดการ cast</strong> – <code>List&lt;String&gt;</code> → ดึงออกมาเป็น <code>String</code> เลย</li>
                    <li><strong>Reusable</strong> – เขียน class/method ครั้งเดียว รองรับหลาย type</li>
                </ul>

                <div class="divider"></div>

                <h3 class="topic">7.3 Generic Class – <code>Box&lt;T&gt;</code></h3>
                <p><code>class Box&lt;T&gt; { ... }</code> → <code>T</code> คือ <strong>type parameter</strong> (placeholder แทนชนิดจริง)</p>
                <p>เวลาใช้จริงต้องใส่ type argument เช่น:</p>
                <pre><code>Box&lt;String&gt;  stringBox = new Box&lt;&gt;();
Box&lt;Integer&gt; intBox    = new Box&lt;&gt;();</code></pre>

                <div class="hint">
                    กฎ: Generics ใช้กับ <strong>reference type เท่านั้น</strong> → <code>Box&lt;int&gt;</code> ❌ ต้องใช้ <code>Box&lt;Integer&gt;</code> ✔
                </div>

                <p><span class="label">Primitive vs Wrapper</span></p>
                <div class="table-wrapper">
                    <table>
                        <thead>
                            <tr>
                                <th>Primitive</th>
                                <th>Wrapper (ใช้กับ Generics)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>int</code></td>
                                <td><code>Integer</code></td>
                            </tr>
                            <tr>
                                <td><code>double</code></td>
                                <td><code>Double</code></td>
                            </tr>
                            <tr>
                                <td><code>boolean</code></td>
                                <td><code>Boolean</code></td>
                            </tr>
                            <tr>
                                <td><code>char</code></td>
                                <td><code>Character</code></td>
                            </tr>
                            <tr>
                                <td>...</td>
                                <td>...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="divider"></div>

                <h3 class="topic">7.4 Generic Method</h3>
                <pre><code>public static &lt;T&gt; void printArray(T[] array) {
    for (T element : array) {
        System.out.println(element);
    }
}</code></pre>
                <ul>
                    <li><code>&lt;T&gt;</code> หน้า <code>void</code> = ประกาศว่าเมธอดนี้เป็น generic method ใช้ type parameter ชื่อ T</li>
                    <li>ใช้ได้ทั้งใน generic class และ non-generic class</li>
                    <li>เวลาเรียก
                        <pre><code>printArray(new Integer[]{1,2,3});
printArray(new String[]{"A","B"});</code></pre>
                    </li>
                    <li>Compiler จะ infer ว่า <code>T</code> คืออะไรจากอาร์เรย์ที่ส่งเข้าไป</li>
                </ul>

                <div class="divider"></div>

                <h3 class="topic">7.5 Generic Interface &amp; Bounded Types</h3>
                <p>ตัวอย่าง Generic interface: <code>Comparable&lt;T&gt;</code>, <code>List&lt;T&gt;</code></p>
                <p><strong>Bounded Type</strong> – จำกัดว่า T ต้องสืบทอดจาก type ไหน</p>
                <pre><code>class Stats&lt;T extends Number&gt; {
    // ใช้ T.doubleValue() ได้ เพราะรู้ว่า T เป็น Number อย่างน้อย
}</code></pre>
                <ul>
                    <li>อนุญาต: <code>Stats&lt;Integer&gt;</code>, <code>Stats&lt;Double&gt;</code>, <code>Stats&lt;Number&gt;</code></li>
                    <li>ไม่อนุญาต: <code>Stats&lt;String&gt;</code>, <code>Stats&lt;Object&gt;</code></li>
                    <li>ข้อดี:
                        <ul>
                            <li>compiler บังคับให้ใช้ type ถูก</li>
                            <li>เรียกเมธอดของ <code>Number</code> เช่น <code>doubleValue()</code>, <code>intValue()</code> ได้เลย</li>
                        </ul>
                    </li>
                </ul>

            </div>
        </section>

        <!-- SECTION 8 -->
        <section id="sec8" class="section">
            <div class="section-header">
                <div>
                    <div class="section-title">บทที่ 8 – Wildcards &amp; PECS</div>
                    <div class="section-subtitle">Module8_Wildcards_CSC250</div>
                </div>
            </div>
            <div class="section-body">

                <h3 class="topic">8.1 List, Array, ArrayList</h3>
                <ul>
                    <li>Array <code>T[]</code> – ขนาดตายตัว, ใส่ primitive ได้, ไม่อยู่ใน Collection Framework</li>
                    <li><code>ArrayList&lt;T&gt;</code> – ขยาย/หดได้, เป็น implementation ของ <code>List&lt;T&gt;</code></li>
                    <li>ใช้ generics กับ <code>List&lt;T&gt;</code> เพื่อบังคับให้เป็น homogeneous (ของชนิดเดียวกัน)
                        <ul>
                            <li><code>List</code> เฉย ๆ = heterogeneous ได้หมด (ปนหลายชนิด)</li>
                            <li><code>List&lt;String&gt;</code> = บังคับให้ทุก element เป็น <code>String</code></li>
                        </ul>
                    </li>
                </ul>

                <div class="divider"></div>

                <h3 class="topic">8.2 ทำไมต้องมี Wildcard</h3>
                <p>ปัญหา:</p>
                <pre><code>public static void printNumbers(List&lt;Number&gt; list) { ... }

List&lt;Integer&gt; intList = ...
printNumbers(intList); // ❌ compile error</code></pre>
                <p>แม้ว่า <code>Integer extends Number</code> แต่ <code>List&lt;Integer&gt;</code> ไม่ใช่ <code>List&lt;Number&gt;</code> → เพราะ generics เป็น <strong>invariant</strong></p>
                <p><strong>แนวทางแก้</strong> → ใช้ wildcard:</p>
                <pre><code>public static void printNumbers(List&lt;? extends Number&gt; list) { ... }</code></pre>
                <p>ตอนนี้ <code>List&lt;Integer&gt;</code>, <code>List&lt;Double&gt;</code> ส่งเข้าได้หมด → เหมาะกับเมธอดที่ “อ่านอย่างเดียว”</p>

                <div class="divider"></div>

                <h3 class="topic">8.3 ชนิดของ Wildcard</h3>
                <ul>
                    <li><code>&lt;?&gt;</code> – Unbounded wildcard</li>
                    <li><code>&lt;? extends T&gt;</code> – Upper-bounded (producer)</li>
                    <li><code>&lt;? super T&gt;</code> – Lower-bounded (consumer)</li>
                </ul>

                <div class="divider"></div>

                <h3 class="topic">8.4 Unbounded Wildcard – <code>List&lt;?&gt;</code></h3>
                <ul>
                    <li>ใช้เมื่อ “ไม่แคร์จริง ๆ ว่าข้างในเป็น type อะไร” แค่จะ iterate / print ดู</li>
                    <li>อ่านได้เป็น <code>Object</code></li>
                    <li>เขียน (add) ไม่ได้ ยกเว้น <code>null</code></li>
                </ul>
                <div class="table-wrapper">
                    <table>
                        <thead>
                            <tr>
                                <th>การกระทำ</th>
                                <th><code>List&lt;?&gt;</code></th>
                                <th>อธิบาย</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>get(0)</code></td>
                                <td>✅ ได้ (เป็น <code>Object</code>)</td>
                                <td>อ่านได้ปลอดภัย</td>
                            </tr>
                            <tr>
                                <td><code>add(123)</code></td>
                                <td>❌</td>
                                <td>type ข้างในไม่รู้</td>
                            </tr>
                            <tr>
                                <td><code>add("A")</code></td>
                                <td>❌</td>
                                <td>เหมือนกัน</td>
                            </tr>
                            <tr>
                                <td><code>add(null)</code></td>
                                <td>✅</td>
                                <td><code>null</code> เข้ากับทุก reference type</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="divider"></div>

                <h3 class="topic">8.5 Upper-Bounded – <code>List&lt;? extends Number&gt;</code></h3>
                <ul>
                    <li>ใช้เมื่อเมธอด “อ่านค่าออกมาในฐานะ <code>Number</code> หรือ subtype ของมัน”</li>
                    <li>อ่านได้เป็น <code>Number</code></li>
                    <li>เพิ่ม (add) ไม่ได้ (ยกเว้น <code>null</code>) เพราะ compiler ไม่รู้ว่าจริง ๆ คือ <code>List&lt;Integer&gt;</code> หรือ <code>List&lt;Double&gt;</code></li>
                </ul>
                <div class="table-wrapper">
                    <table>
                        <thead>
                            <tr>
                                <th>การกระทำ</th>
                                <th><code>List&lt;? extends Number&gt;</code></th>
                                <th>อธิบาย</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>get(0)</code></td>
                                <td>✅ → <code>Number</code></td>
                                <td>ใช้ <code>doubleValue()</code> ฯลฯ ได้</td>
                            </tr>
                            <tr>
                                <td><code>add(1)</code></td>
                                <td>❌</td>
                                <td>ถ้าจริง ๆ คือ <code>List&lt;Double&gt;</code> จะพัง</td>
                            </tr>
                            <tr>
                                <td><code>add(3.14)</code></td>
                                <td>❌</td>
                                <td>ถ้าจริง ๆ คือ <code>List&lt;Integer&gt;</code> จะพัง</td>
                            </tr>
                            <tr>
                                <td><code>add(null)</code></td>
                                <td>✅</td>
                                <td>ปลอดภัย</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div class="hint"><code>? extends T</code> = <strong>Producer</strong> → เน้น “ผลิตค่าออกมาให้เราอ่าน”</div>

                <div class="divider"></div>

                <h3 class="topic">8.6 Lower-Bounded – <code>List&lt;? super Integer&gt;</code></h3>
                <ul>
                    <li>รับได้ <code>List&lt;Integer&gt;</code>, <code>List&lt;Number&gt;</code>, <code>List&lt;Object&gt;</code></li>
                    <li>เราสามารถ <code>add(Integer)</code> ได้ปลอดภัย (เพราะทุกลิสต์เหล่านี้รับ Integer ได้)</li>
                    <li>เวลา <code>get()</code> ออกมา type คือ <code>Object</code> (ต้อง cast เองถ้าจะใช้เป็น <code>Integer</code>)</li>
                </ul>
                <div class="table-wrapper">
                    <table>
                        <thead>
                            <tr>
                                <th>การกระทำ</th>
                                <th><code>List&lt;? super Integer&gt;</code></th>
                                <th>อธิบาย</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>add(1)</code></td>
                                <td>✅</td>
                                <td>ปลอดภัย</td>
                            </tr>
                            <tr>
                                <td><code>get(0)</code></td>
                                <td>✅ แต่ type คือ <code>Object</code></td>
                                <td>ต้อง cast เองถ้าจะใช้เป็น <code>Integer</code></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div class="hint"><code>? super T</code> = <strong>Consumer</strong> → เมธอด “กินค่า T เข้าไป (write)” ได้ดี</div>

                <div class="divider"></div>

                <h3 class="topic">8.7 กฎทอง – PECS</h3>
                <p><strong>PECS = Producer Extends, Consumer Super</strong></p>
                <div class="table-wrapper">
                    <table>
                        <thead>
                            <tr>
                                <th>ชนิด</th>
                                <th>ความหมาย</th>
                                <th>อ่าน</th>
                                <th>เขียน</th>
                                <th>ใช้เมื่อ</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>&lt;?&gt;</code></td>
                                <td>ไม่รู้ type</td>
                                <td>✅ as <code>Object</code></td>
                                <td>❌ (ยกเว้น <code>null</code>)</td>
                                <td>เมธอดอ่านเฉย ๆ (debug/print)</td>
                            </tr>
                            <tr>
                                <td><code>&lt;? extends T&gt;</code></td>
                                <td>“อย่างน้อยเป็น T”</td>
                                <td>✅ as <code>T</code></td>
                                <td>❌</td>
                                <td>Producer – อ่านค่าออกมา</td>
                            </tr>
                            <tr>
                                <td><code>&lt;? super T&gt;</code></td>
                                <td>“อย่างน้อยเป็น super ของ T”</td>
                                <td>✅ as <code>Object</code></td>
                                <td>✅ เพิ่ม <code>T</code> ได้</td>
                                <td>Consumer – ใส่ค่าเข้าไป</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div class="hint">
                    ถ้าต้องการทั้งอ่านทั้งเขียนแบบแน่น ๆ → <strong>ไม่ควรใช้ wildcard</strong> ให้ใช้ <code>List&lt;T&gt;</code> ปกติ
                </div>

            </div>
        </section>

        <!-- SECTION 9 -->
        <section id="sec9" class="section">
            <div class="section-header">
                <div>
                    <div class="section-title">บทที่ 9 – Nested / Inner / Local / Anonymous / Adapter</div>
                    <div class="section-subtitle">Module9_Nested_Classes_CSC250</div>
                </div>
            </div>
            <div class="section-body">

                <h3 class="topic">9.1 Inner Class (non-static nested)</h3>
                <ul>
                    <li>คลาสที่ประกาศ “ข้างใน” อีกคลาส และผูกกับ <strong>instance</strong> ของ outer class</li>
                    <li>สามารถเข้าถึง field/method (แม้เป็น <code>private</code>) ของ outer class ได้</li>
                </ul>
                <pre><code>Outer outer = new Outer();
Outer.Inner in = outer.new Inner();</code></pre>
                <p>เหมาะเมื่อ inner class “ผูกแน่นกับ state ของ outer” เช่น iterator, helper ที่ใช้ field ของ outer ตลอด</p>

                <div class="divider"></div>

                <h3 class="topic">9.2 <code>Outer.this</code> คืออะไร</h3>
                <ul>
                    <li>ใน inner class, คำว่า <code>this</code> หมายถึง “instance ของ inner class เอง”</li>
                    <li>ถ้า outer กับ inner มีชื่อ field ซ้ำกัน เช่น <code>name</code>
                        <ul>
                            <li><code>this.name</code> → <code>Inner.name</code></li>
                            <li><code>Outer.this.name</code> → <code>Outer.name</code></li>
                        </ul>
                    </li>
                </ul>
                <div class="table-wrapper">
                    <table>
                        <thead>
                            <tr>
                                <th>คำ</th>
                                <th>อ้างถึง</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>this</code></td>
                                <td>instance ของ inner class</td>
                            </tr>
                            <tr>
                                <td><code>Outer.this</code></td>
                                <td>instance ของ outer ที่สร้าง inner ตัวนี้</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div class="hint">
                    ใช้ได้เฉพาะ <strong>non-static inner class</strong> เท่านั้น เพราะ static nested class ไม่มี outer instance ผูกอยู่
                </div>

                <div class="divider"></div>

                <h3 class="topic">9.3 Local Class (ประกาศในเมธอด)</h3>
                <ul>
                    <li>คือคลาสที่อยู่ “ภายใน <code>method/constructor/block</code>”</li>
                    <li>Scope จำกัดอยู่ใน block นั้นเท่านั้น</li>
                    <li>สามารถ capture ตัวแปร local ได้ แต่ต้องเป็น <strong>effectively final</strong> (ค่าห้ามเปลี่ยนหลังประกาศ)</li>
                </ul>
                <p>ใช้เมื่อ:</p>
                <ul>
                    <li>ต้องการ helper class เล็ก ๆ ใช้เฉพาะใน method นั้น</li>
                    <li>ไม่อยากให้คนอื่นเห็นในระดับคลาส (ซ่อนรายละเอียดได้ดี)</li>
                </ul>

                <div class="divider"></div>

                <h3 class="topic">9.4 Anonymous Class</h3>
                <p>“คลาสไม่มีชื่อ” เขียนและสร้าง object พร้อมกันเลย</p>
                <pre><code>Greeting g = new Greeting() {
    @Override
    public void sayHello() {
        System.out.println("Hello from Anonymous Class");
    }
};</code></pre>
                <ul>
                    <li>ใช้กับ:
                        <ul>
                            <li>interface</li>
                            <li>abstract class</li>
                        </ul>
                    </li>
                    <li>ไม่มี constructor (เพราะไม่มีชื่อคลาส)</li>
                    <li>เหมาะกับ case ที่ต้อง implement interface/abstract class “ครั้งเดียวจบ” เช่น event handler</li>
                </ul>

                <div class="divider"></div>

                <h3 class="topic">9.5 Lambda Expression</h3>
                <p>รูปแบบสั้น ๆ ของ anonymous implementation สำหรับ <strong>functional interface</strong> (มี abstract method เดียว)</p>
                <p>ตัวอย่าง syntax:</p>
                <ul>
                    <li><code>x -&gt; x * x</code></li>
                    <li><code>(a, b) -&gt; a + b</code></li>
                </ul>
                <p>ใช้คู่กับ method ที่รับ functional interface เช่น</p>
                <pre><code>List&lt;Integer&gt; numbers = ...
numbers.forEach(n -&gt; { System.out.println(n); });</code></pre>
                <p><strong>Anonymous vs Lambda</strong></p>
                <ul>
                    <li>Anonymous class → สร้าง “ชนิดใหม่” จริง ๆ, <code>this</code> = anonymous object</li>
                    <li>Lambda → ไม่มีชนิดใหม่, แค่ implementation ของ functional interface, <code>this</code> = instance ของ outer class</li>
                </ul>

                <div class="divider"></div>

                <h3 class="topic">9.6 Adapter Classes &amp; Adapter Pattern</h3>
                <p><strong>Adapter class (ใน AWT/Swing)</strong></p>
                <ul>
                    <li>เช่น <code>MouseAdapter</code>, <code>KeyAdapter</code>, <code>WindowAdapter</code></li>
                    <li>เป็นคลาสที่ implements interface ใหญ่ ๆ (เช่น <code>MouseListener</code>) โดยทำเมธอดว่าง ๆ ไว้</li>
                    <li>เวลาใช้ เราแค่ <code>extends</code> adapter แล้ว override เฉพาะเมธอดที่สนใจ</li>
                </ul>
                <pre><code>class MyMouseAdapter extends MouseAdapter {
    @Override
    public void mouseClicked(MouseEvent e) {
        System.out.println("Mouse clicked!");
    }
}</code></pre>
                <ul>
                    <li>ข้อดี:
                        <ul>
                            <li>ไม่ต้อง implement เมธอดทั้งหมดของ interface ใหญ่</li>
                            <li>ลดโค้ดซ้ำและ boilerplate</li>
                        </ul>
                    </li>
                </ul>

                <p><strong>Adapter Pattern (เชิง design pattern)</strong></p>
                <ul>
                    <li>ใช้ “แปลงหน้า interface” ให้สองระบบคุยกันได้โดยไม่ต้องไปแก้โค้ดเดิม</li>
                    <li>ใน Java แนะนำใช้ <strong>object adapter (composition)</strong> มากกว่า class adapter (multiple inheritance)</li>
                </ul>

                <p><strong>สรุป nested class ทั้งหมด</strong></p>
                <div class="table-wrapper">
                    <table>
                        <thead>
                            <tr>
                                <th>ชนิด</th>
                                <th>อยู่ที่ไหน</th>
                                <th>มีชื่อไหม</th>
                                <th>เข้าถึง outer ได้ไหม</th>
                                <th>ใช้เมื่อ</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Inner class</td>
                                <td>ในคลาส</td>
                                <td>✅</td>
                                <td>✅ (มี <code>Outer.this</code>)</td>
                                <td>helper ผูกกับ state ของ outer</td>
                            </tr>
                            <tr>
                                <td>Local class</td>
                                <td>ใน method/block</td>
                                <td>✅</td>
                                <td>✅ แต่จำกัด</td>
                                <td>helper ชั่วคราว</td>
                            </tr>
                            <tr>
                                <td>Anonymous</td>
                                <td>ใน expression</td>
                                <td>❌</td>
                                <td>✅</td>
                                <td>ใช้ครั้งเดียว implement interface/abstract</td>
                            </tr>
                            <tr>
                                <td>Adapter class</td>
                                <td>คลาสปกติ</td>
                                <td>✅</td>
                                <td>❌ พิเศษ</td>
                                <td>ลดงาน implement interface ใหญ่ ๆ</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

            </div>
        </section>

        <!-- GLOSSARY -->
        <section id="glossary" class="section">
            <div class="section-header">
                <div>
                    <div class="section-title">Glossary – คำศัพท์ในโค้ด + แปลไทย</div>
                    <div class="section-subtitle">ใช้ได้ทุกบท</div>
                </div>
            </div>
            <div class="section-body">

                <h3 class="topic">กลุ่มคลาส / อินเทอร์เฟซ</h3>
                <div class="glossary-group">
                    <div class="glossary-item">
                        <div class="glossary-term"><code>class</code></div>
                        <div class="glossary-desc">ประกาศ “คลาส” (พิมพ์เขียวของ object)</div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>interface</code></div>
                        <div class="glossary-desc">ประกาศสัญญา/ความสามารถ (มีแค่ method signature + default/static)</div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>extends</code></div>
                        <div class="glossary-desc">
                            <div>class extends class / abstract class = สืบทอดพฤติกรรมและ field</div>
                            <div>interface extends interface = ขยายสัญญาเพิ่ม</div>
                        </div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>implements</code></div>
                        <div class="glossary-desc">class รับสัญญาจาก interface ต้องเขียนเมธอดที่กำหนด</div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>abstract</code></div>
                        <div class="glossary-desc">คลาสหรือเมธอดที่ “ยังไม่สมบูรณ์” ต้องให้ subclass implement</div>
                    </div>
                </div>

                <h3 class="topic">การมองเห็น (Access Modifier)</h3>
                <div class="glossary-group">
                    <div class="glossary-item">
                        <div class="glossary-term"><code>public</code></div>
                        <div class="glossary-desc">ใช้ได้ทุกที่</div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>private</code></div>
                        <div class="glossary-desc">ใช้ได้เฉพาะภายในคลาสนั้น</div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>protected</code></div>
                        <div class="glossary-desc">ใช้ได้ในคลาสเดียวกัน + subclass + package เดียวกัน</div>
                    </div>
                </div>

                <h3 class="topic">ตัวแปร / เมธอดระดับคลาส</h3>
                <div class="glossary-group">
                    <div class="glossary-item">
                        <div class="glossary-term"><code>static</code></div>
                        <div class="glossary-desc">เป็นของ “คลาส” ไม่ผูกกับ object ใด object หนึ่ง</div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>final</code></div>
                        <div class="glossary-desc">
                            <div>กับตัวแปร = เปลี่ยนค่าไม่ได้ (constant)</div>
                            <div>กับเมธอด = ห้าม override</div>
                            <div>กับคลาส = ห้ามมี subclass</div>
                        </div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>default</code> (ใน interface)</div>
                        <div class="glossary-desc">เมธอดมี body ใน interface ได้ ใช้เป็น implementation พื้นฐาน</div>
                    </div>
                </div>

                <h3 class="topic">เกี่ยวกับเมธอด</h3>
                <div class="glossary-group">
                    <div class="glossary-item">
                        <div class="glossary-term"><code>void</code></div>
                        <div class="glossary-desc">ไม่คืนค่า</div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>boolean</code></div>
                        <div class="glossary-desc">ชนิด “จริง/เท็จ” (<code>true</code>/<code>false</code>)</div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>return</code></div>
                        <div class="glossary-desc">คืนค่าจาก method</div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>@Override</code></div>
                        <div class="glossary-desc">annotation บอกว่าเมธอดนี้ override จาก superclass/interface</div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>@FunctionalInterface</code></div>
                        <div class="glossary-desc">annotation บอกว่า interface นี้ตั้งใจให้เป็น functional interface (มี abstract method เดียว)</div>
                    </div>
                </div>

                <h3 class="topic">เกี่ยวกับ object / this / super</h3>
                <div class="glossary-group">
                    <div class="glossary-item">
                        <div class="glossary-term"><code>new</code></div>
                        <div class="glossary-desc">สร้าง instance ใหม่ของคลาส</div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>this</code></div>
                        <div class="glossary-desc">อ้างถึง object ปัจจุบันของคลาสนั้น</div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>Outer.this</code></div>
                        <div class="glossary-desc">ใน inner class ใช้อ้างถึง object ของ outer class</div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>super</code></div>
                        <div class="glossary-desc">
                            <div>ในคลาส: เรียกเมธอด/constructor ของ superclass</div>
                            <div>ใน interface default conflict: <code>A.super.method()</code> เลือกเรียก default method ของ interface A</div>
                        </div>
                    </div>
                </div>

                <h3 class="topic">เกี่ยวกับ Generics</h3>
                <div class="glossary-group">
                    <div class="glossary-item">
                        <div class="glossary-term"><code>&lt;T&gt;</code></div>
                        <div class="glossary-desc">type parameter (ชื่อ T จะเป็นอะไรก็ได้ เช่น <code>E</code>, <code>K</code>, <code>V</code>)</div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>Box&lt;T&gt;</code></div>
                        <div class="glossary-desc">generic class ที่ใช้ T แทน type จริงตอนคอมไพล์</div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>List&lt;T&gt;</code></div>
                        <div class="glossary-desc">ลิสต์ที่เก็บค่า type เดียวกัน (homogeneous)</div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>&lt;?&gt;</code></div>
                        <div class="glossary-desc">unknown type (unbounded wildcard)</div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>&lt;? extends Number&gt;</code></div>
                        <div class="glossary-desc">upper bound: “T เป็น subclass ของ <code>Number</code>”</div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>&lt;? super Integer&gt;</code></div>
                        <div class="glossary-desc">lower bound: “T เป็น superclass ของ <code>Integer</code>”</div>
                    </div>
                </div>

                <h3 class="topic">Lambda &amp; Functional Interface</h3>
                <div class="glossary-group">
                    <div class="glossary-item">
                        <div class="glossary-term"><code>parameter -&gt; expression</code></div>
                        <div class="glossary-desc">lambda expression เช่น <code>x -&gt; x * x</code></div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term"><code>(a, b) -&gt; a + b</code></div>
                        <div class="glossary-desc">lambda สองพารามิเตอร์</div>
                    </div>
                    <div class="glossary-item">
                        <div class="glossary-term">ใช้แทน anonymous class</div>
                        <div class="glossary-desc">ที่มีเมธอด abstract ตัวเดียวได้ เช่น <code>Runnable</code>, <code>Comparator&lt;T&gt;</code>, <code>Discount</code></div>
                    </div>
                </div>

            </div>
        </section>

    </main>
</body>

</html>
